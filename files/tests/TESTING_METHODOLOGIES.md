## Методологии в тестировании (TDD, BDD, Last-Test)

### 1) TDD методолгия

**TDD** (сокр. от *[Test-driven development](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0_%D1%87%D0%B5%D1%80%D0%B5%D0%B7_%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)*, дословно "разработка через тестирование") - техника разработки программного обеспечения, которая основывается на повторении очень коротких циклов разработки : сначала пишется тест, покрывающий желаемое изменение, затем пишется код, который позволят пройти тест и под конец проводится рефакторинг нового кода к соответствующим стандартам.

#### Основные принципы TDD

В TDD есть 3 основных правила от дядюшки Боба:
- Пиши только тот код, который протестирован.
- Начинай писать тесты с малого, а затем наращивай их.
- Пиши ровно столько кода, сколько необходимо для прохождения теста.

#### Цикл разработки через тестирование

Базовый процесс следования TDD содержит 3 этапа:

1. **Красный** - написание теста, который не проходится. Только одного теста. Он должен быть простым, его назначение - это не функциональность, а определение границ использования того, что ты сейчас создаешь. Начинаешь с вводных более базовых вопросов, постепенно переходя к самым непредсказуемым вещам, случаям, которые можешь придумать:
    - "Что я буду передавать этому действию?"
    - "Что эта функция будет возвращать?"
    - "Что произойдет, если передать параметр null?"
    - "Что произойдет, когда я передам отрицательное число?"
    - "А как насчет передачи строки, когда код ожидает увидеть число?"
2. **Зеленый** - прохождение падающих тестов, как можно скорее. Не думай о том, как выглядит твой код, насколько он эффективен, главное - исправление падающих тестов по одному. Твоя цель - прохождение теста, чтобы ты мог удостовериться, что еще одна часть функциональности покрыта тестами.
3. **Рефакторинг** - это рефакторинг, реструктуризация и организация твоего кода. Этап рефакторинга может происходить в любой момент: после 1 красного/зеленого цикла, после четырёх или более. Рефакторинг должен касаться только реструктуризации своего кода и придания ему более 
читаемого вида. Не забывай уделять внимание и усовершенствованию тестов, но не делай рефакторинг кода и тестов одновременно.

#### Вывод

Большинство людей, решивших окунуться в TDD, осознают, что в их знаниях много пробелов, которые могут создать проблемы в этом новом мире. Даже если со знаниями у вас все в порядке, вы должны осознавать, что в любом случае первое время вы будете тренировать свой мозг решать программные проблемы непривычным способом. На самом деле, это одно из самых больших препятствий при переходе на TDD — выработка нового стиля программирования, который заставляет вас думать о маленьких шагах и разрабатывать API, как будто он уже написан. Хороший способ начать практиковать TDD — использовать state-based тестирование (от перев. — подход, при котором проверяется состояние объекта после прохождения теста). Как только вы набьете руку на state-based тестировании, вы сможете сочетать его с interaction-based тестированием (от перев. — подход, при котором тестируется взаимодействие объектов, поведение методов, последовательность их вызовов и т.д.).

В общем, вы должны принять решение следовать путем TDD достаточно долго, чтобы это стало неотъемлемой частью вашего рабочего подхода. В противном случае вы рискуете сдаться слишком рано, так и не узнал о преимуществах, которые TDD может принести в ваш арсенал разработчика.

### 2) BDD методолгия

**BDD** (сокр. от *[Behavior-driven development](https://ru.wikipedia.org/wiki/BDD_\(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5\))* , дословно "разработка через поведение") - это методология разработки программного обеспечения, являющаяся ответвлением от методологии разработки через тестирование (TDD).

#### Принципы BDD

Тесты для некоторой единицы программного обеспечения должны быть описаны с точки зрения желаемого поведения программируемого устройства. Под желаемым поведением здесь понимается такое, которое имеет ценность для бизнеса. Описание желаемого поведения даётся с помощью спецификации поведения.
    
Спецификация поведения строится в полу-формальной форме. В настоящее время в практике BDD устоялась следующая структура:

1. Заголовок (Title). В сослагательной форме должно быть дано описание бизнес-цели.
2. Описание (Narrative). В краткой и свободной форме должны быть раскрыты следующие вопросы:
    - Кто является заинтересованным лицом данной истории;
    - Что входит в состав данной истории;
    - Какую ценность данная история предоставляет для бизнеса.
3. Сценарий (Scenarios). В одной спецификации может быть один и более сценариев, каждый из которых раскрывает одну из ситуаций поведения пользователя, тем самым конкретизируя описание спецификации. Каждый сценарий обычно строится по одной и той же схеме:
    - Начальные условия (одно или несколько);
    - Событие, которое инициирует начало этого сценария;
    - Ожидаемый результат или результаты.

BDD не предоставляет каких-либо формальных правил, но настаивает на том, чтобы использовался ограниченный стандартный набор фраз, который включал бы все элементы спецификации поведения. В 2007 году Дэном Нортом был предложен шаблон для спецификации, который получил популярность и впоследствии стал известен как язык Gherkin.

#### Вывод

В подходе BDD нет ничего нового или революционного. Это просто эволюционное ответвление подхода TDD, где слово "тест" заменено словом "должен". Если отложить в сторону слова, то многие найдут понятие "должен" более естественным для процесса разработки, чем понятие "тест". Мышление в терминах функциональности (того, что код должен делать), приводит к подходу, когда сначала пишутся классы для проверки спецификации, которые, в свою очередь, могут оказаться очень эффективным инструментом реализации.

В разработке, основанной на поведении, нет необходимости думать о тестах, достаточно сконцентрироваться на требованиях к приложению и сделать так, чтобы поведение приложения соответствовало этим требованиям. Суть процесса - клиент или эксперт в предметной области - говорит, что именно система, функция или приложение должны делать, а мы используя BDD для проверки, что правильно услышали и реализовали требования клиента.

### 3) TDD vs Last-test

#### Работает ли TDD?

Самые прогрессивные деятели мира разработки программного обеспечения признавали и признают до сих пор, что TDD это очень действенный инструмент в арсенале программиста. Это не “серебряная пуля”, но время доказало, что это работает. Мое скромное мнение, что разработка через тестирование — это гениальная техника.

Мир, как и наш аутсорс, эволюционирует, теперь даже новоиспеченный junior-разработчик или заказчик далекий от программирования знает, что тесты необходимы (или догадывается об этом). Сложно представить себе автопром или пищепром без тестирования (все тогда травились бы едой или разбивались бы на дорогах), хотя, на этом тоже можно было бы сэкономить. Но если к тому, что необходимо писать тесты, все уже давно пришли, то к тому, как именно это делать — еще нет.

Это дорого. Это не купит заказчик. У нас нет на это времени, мы знаем, что это хорошо, но у нас слишком жесткие сроки. Подобную функциональность не получится тестировать этим подходом. Это работает только для модульных тестов. Типичные ответы на вопрос: “Почему не TDD?”.

И при этом, все равно могут писать тесты, но только делать это в стиле Test-Last.

#### TDD - это дорого?

Тесты должны быть на всех фронтах и тылах, но во всем должен быть здравый смысл. Автоматизация это не панацея, ею не стоит увлекаться. Надо понимать, что большую часть тестов, а это модульные, должны писать разработчики. Доля тестировщиков-автоматизаторов гораздо меньше. Конечно, все основывается на выделенном бюджете, балом правит заказчик. В этом случае всегда лучше руководствоваться пирамидой тестирования.

Как еще можно сэкономить? Давайте урежем время на документирование, но ценой чего? А почему бы не сделать тесты документацией?

Новое (на самом деле не такое уж и новое) расширение подхода TDD решает эту проблему. Вобрав в себя лучшие принципы [Domain-Driven Design](https://en.wikipedia.org/wiki/Domain-driven_design) Эрика Эванса, TDD эволюционировал в “Behavior-Driven Development или Specification-Driven Development“

Дэн Норс впервые описал этот подход в 2006 году, презентовав его позже на конференции 2009-го года в Лондоне с предложением "А давайте превратим наши тесты в спецификацию?". Т.е. теперь, когда мы пишем отказной тест, мы делаем это через [DSL](https://en.wikipedia.org/wiki/Domain-specific_language) (Предметно-ориентированный язык / Domain-Specific Language), попутно описывая поведение разрабатываемой функции на языке доступном всем.

#### Test-Last

Так а что же Test-Last? Это плохой подход, который надо выбросить?
    
Я так не считаю. Для меня это неотъемлемая часть TDD. Звучит странно, не правда ли? Я считаю Test-Last нулевым шагом в TDD. Именно с этой техники я советую всем начинать. Ведь все познается в сравнении. Только те, кто работал в этом стиле, а позже перешел на TDD, могут осознать всю ценность идей Кента Бека. Юному джедаю нужно побывать на обеих сторонах. Если вы сейчас работаете в стиле Test-Last, то продолжайте. Я серьезно. Старайтесь добиться как можно более полного покрытия, изолируйте тесты, пишите заглушки и пытайтесь дотянуться до самых спрятанных функций. При оценке и планировании, прикидывайте на глаз, сколько займет времени реализовать тесты.

А потом постепенно (на одном из своих следующих новых проектов) попробуйте начать разрабатывать в стиле TDD.
